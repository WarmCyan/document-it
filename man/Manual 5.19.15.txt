Document It Manual
--------------------------------
Last updated: 5/19/2015
--------------------------------

The Document It engine is a piece of software that takes a code file written in an object oriented programming language
(currently it only supports Java, C++, C#, and any other language that uses comment types '//' and '/* */') and creates
API documentation similar to those generated by javadocs.

The engine does this by analyzing 'syntax blocks' inside of comments in your code. A syntax block can be denoted like so:

//{ }
OR 
/* { } */

Both of these versions can be spread over multiple lines:

//{
// syntax
//}

OR

/*{
syntax
}*/

The engine will take all the content within those braces and try to analyze it. In order for it to know anything about
the code that the syntax block is supposed to represent, you can use 'tags' to denote different things.

I'll start off with a simple example, and then explain what it's doing:

/*{
@f:int rollTheDie @d:This function will randomly return a number, based on the number of dice being rolled.
@i: 
	@v:int numberOfDice @d:The number of dice for the program to roll, the bounds of the returned number are defined by 
	this (ex: 2 dice means a number between 2-12, 1 die means 1-6, etc)
	@v:int rolls @d:The number of times to roll the dice. (will continue to add to the previous roll number)
@o: Returns a random number, within the inteval of (numberOfDice, numberOfDice * 6)
}*/

(the above syntax represents the function: public int rollTheDie(int numberOfDice, int rolls))

So inside the syntax example, you see multiple '@' symbols. Each one of these denotes a 'tag.' A tag defines what type of 
code object you're currently defining. For instance, a function, a variable, a class, an interface, a constructor, etc.
For each of these tags, you start with an '@' then use the name of the tag (see below), followed by a colon ':' and then 
the tag content.

-------------------------
	TAG TYPES
-------------------------

'@cl' (or '@class') represents a class. Currently, the engine REQUIRES that each file you document MUST have ONE class or 
	interface, no combination, and no more or less than one. Your syntax block describing the class/interface must be 
	the first syntax block in the code file. (This is currently necessary so that the engine properly registers that
	all following code objects are registered with this 'root' class or interface.)
	A class can have a description (@d)

'@intf' (or '@interface') represents an interface. See previous for more details. An interface can have a description (@d)

'@f' (or '@function') represents a function, a function can have a description (@d), an input (@i, an input is basically 
	the collection of input parameter variables) and an output (@o, the statement describing what the function will return)

'@cnst' (or '@constant') represents a constant. It can have a description (@d)

'@c' (or '@constructor') represents a class constructor. It can have a description (@d), and an input (@i, collection of input 
	parameter variables)

'@p' (or '@property') represents a property, or getter/setter. It can have a description (@d). Given that some languages handle
	properties separately from functions, syntax for properties DON'T allow for inputs (@i) (if this is necessary to have, 
	make it a function instead)

'@i' (or '@input') represents a collection of input parameter variables. By itself, this tag doesn't do anything, but it will
	collect all variables (@v) and assosciated variable descriptions (@d) that follow it. This can optionally be attached
	to either a constructor (@c) or function (@f)

'@v' (or '@variable') represents a variable. (Normally used in the context of an input (@i).) Can have a description (@d)

'@d' (or '@description') represents a description of whatever tag came before it. It's a string of text you can write that will
	be placed next to whatever object it's describing in the documentation file. Descriptions can be applied to: classes (@cl),
	interfaces (@intf), functions (@f), constants (@cnst), constructors (@c), properties (@p), and variables (@v).

'@o' (or '@output') represents a statement saying what a function will return. Can only be applied to a function (@f)

'@l' (or '@link') this will be explained more in depth later on, but essentially allows interlinking between different documentation 
	files of the same project.

Whenever the engine sees one of these tags, it will take all the text after the colon until the next tag, then saves this 
as the value of that tag.
When it's analyzing the contents of certain tag values, it breaks everything down into the words, and makes associations based on placement.

For instance, if you have a function that's both static and returns an int, you would mark it like so:
// { @f: static int myFunction @d:the description. }

The engine takes the LAST word in the function tag value (myFunction) and assigns that as the function NAME. Then it takes everything
before that (static int), and assigns it as the function TYPE.
The engine does this for almost all tags: class, function, property, constructor, constant, and variable.
This should be what the actual code looks like anyway, you have your [return]type/modifers followed by the name, so this is how
the syntax should look as well.

Whitespace is insignificant for the most part, so how you format syntax blocks is pretty flexible.
For example, all of the following syntax blocks would analyze to the exact same result:

// {@f:static int myFunction@d:The description.}

// { @f: static int myFunction @d: The description. }

// { @f: static int myFunction
// 	@d: The Description }

When the parser is analyzing blocks, it takes everything and puts it all on one line anyway (and trims space from tag values) so 
new lines and spaces in between tags don't affect the outcome.
This being said, you can theortically make every syntax block fit on only one line (this may be practical in certain circumstances)


The one important rule layout-wise is that the description tag must ALWAYS be the FIRST tag after whatever object it's describing.
(So in a function, the @d has to go right after the @f tag. If there is an @i and @o tag with the function as well, the description CANNOT
go after either of these.)

Another thing to note is that it's not a requirement to include all tags that can go along with another. You don't have to put descriptions
to anything if you don't want, functions don't require input/variables or outputs, you can mix and match as your code requires.

---------------------------------
	EXAMPLE EXPLAINED
---------------------------------
So now looking back at that first example:

/*{
@f:int rollTheDie @d:This function will randomly return a number, based on the number of dice being rolled.
@i: 
	@v:int numberOfDice @d:The number of dice for the program to roll, the bounds of the returned number are defined by 
	this (ex: 2 dice means a number between 2-12, 1 die means 1-6, etc)
	@v:int rolls @d:The number of times to roll the dice. (will continue to add to the previous roll number)
@o: Returns a random number, within the inteval of (numberOfDice, numberOfDice * 6)
}*/

This syntax block represents a function rollTheDie() of return type int.
It's input variables consist of two ints: numberOfDice, and rolls, each of which has their own description.
We can also tell from the output that it will return a random number based on the input parameters.


---------------------
	LINKS
---------------------
One of the other features this engine supports is linking.
If you're working on a project with multiple classes, there are times you may want parts of your documentation to link to another.
For instance, suppose you have a class TaskManager, and a class Task.
A TaskManager may have functions that return instances of a Task, and in your documentation you want the return type to be a hyperlink
to your Task class documentation. This is achievable through the '@l' or '@link' tag.

The link tag is a specialty tag that gets ignored in the initial parsing/analyzing, and is instead handled when the HTML document is 
generated.

A link tag is also different in that instead of taking every word after it until the next tag, it ONLY takes the word immediately to its
right.

Link tags can be inserted ANYWHERE in other syntax tags. (descriptions, functions [a return type for example], variables [type], etc)

Example: following is a function in class TaskManager that returns a Task instance.

/*{
@f: static @l:Task getMyTask @d:Gets the current running task
}*/

When the document generator sees the '@l:Task', it will replace it with: '<a href='task.html'>Task</a>';
(it automatically takes the value of the link, puts it to lowercase, and adds the .html after it. This works because
the name of the file generated follows the same rules.)
So once documentation is generated for both TaskManager and Task, the hyperlinks in each will link to eachother! (note
that the files must be in the same folder to work properly)

-----------------------
	STYLES
-----------------------
Anytime you generate documentation files, the engine will always check the destination folder for an api_style.css. If it doesn't 
find one, it will make a copy from the folder the engine resides in. If you lose that original copy you can just re-download the pack
and get it. If a destination folder already has an api_style.css, the engine will leave it alone, meaning you can substitute or edit
a stylesheet for a particular project, and it will stay there even when you regenerate the documentation.

If you want a particular stylesheet to apply to ALL your projects, replace the api_style.css in the folder that contains the engine.
(A backup copy is advised however!)

You're more than welcome to edit the stylesheet according to your aesthetic wishes! I have it organized into sections, at the top
of the css files are all the rules you're free to change without having to worry about everything in the css breaking. (I've organized
it into colors, borders, fonts, and misc.)

Anything below the commented line is unsafe to edit however. If you know what you're doing, feel free to mess around with it, but again, 
a backup copy is advised.

------------------------
	LOGS
------------------------
Every time you run the engine, it outputs logging information into log.txt, debug.txt, and errors.txt. (Only in the latter if something goes wrong)

If you ever think something happened that shouldn't have, you got unintended results, or the program randomly crashed, please make a copy of each
one of these logs and email it to the developer (digitalwarriorlabs@gmail.com)

------------------------
     PROJECT FILES (.apiproj)
------------------------
If you're working on a project with a lot of files, and you regenerate documentation frequently, it's very annoying having to 
run the engine on all the files over and over again. For that reason, the program now handles special "project files" which are basically
just settings/configuration files with a list of filenames. The primary usage of these is to specify all files that you want documentation
for, and the engine will handle them all at once.

Here is an example file: testProject.apiproj

-----------------------------------
myClass1.java
myClass2.java
	
#here's a comment, any line that starts with a # is considered a comment, and ignored.
	
moreFiles.java
moreFiles2.java

#settings are here
destination=testingFolder/docs
header=TESTING PROJECT
-----------------------------------

As mentioned, blank lines and lines that start with a pound sign are ignored.
Four files were listed, myClass1.java, myClass2.java, moreFiles.java, and moreFiles2.java. When the program prompts you for a file and you 
give it this, it will take all four of those files and generate the documentation for them.

Other important things to note are that .apiproj files are also checked for settings. (It is recommended to ALWAYS set these when using .apiproj files)
Currently, the only two settings available are "destination" and "header". Destination is the folder where the documentation will be put (you can use
absolute or relative file paths) Header is the title that will appear in the upper left of every documentation page. (The project name for instance)

When you use a .apiproj file, an index file will also be generated along with the documentation. This index html page will contain links and info
regarding all found classes and interfaces within the list of files that you gave it.

IT IS RECOMMENDED TO ALWAYS USE .apiproj FILES WHEN USING THIS PROGRAM. It makes it much easier to generate documentation on large numbers of files
consistently and easily, as well as to provide an index to easily overview your documentation.

------------------------
 Command line arguments
------------------------
If you want to run this program in a batch file, or if for some other reason you don't want to be prompted for a file, you can supply a command line argument.
Right now, the only argument it will accept is the path for a .apiproj file.

So for instance, if you have your environment variables set to pick up the folder where the DICI.exe resides, you could put the following in a .bat file:

DICI testProject.apiproj

then, anytime you call this bat file, it will automatically generate all documentation based on the settings in that .apiproj.